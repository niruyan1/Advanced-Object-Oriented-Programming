
<!-- saved from url=(0075)https://www.eecs.yorku.ca/course_archive/2016-17/F/2030/labs/lab7/lab7.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>Lab 7: Emulating recursion using a stack</title>
  <style>
p
{
	line-height: 150%;
}
ol
{
padding: 0;
margin-left: 3em;
margin-bottom: 1ex;
}
ul
{
padding: 0;
margin-left: 3em;
margin-bottom: 1ex;
}
li
{
	margin-top: 1ex;
	margin-bottom: 1ex;
  line-height: 150%;
}
code
{
  font-weight: bold;
  font-size: 120%;
}
</style>
  
</head>
<body>

<h1>Lab 7: Emulating recursion using a stack</h1>

<p>
Due Dec 5 before 11:59PM
</p>

<p>
When you run a recursive method on a computer, the method and
all of its recursive invocations occupy space in a region of memory named the
<i>call stack</i>. Stack memory is special because
it can be allocated and deallocated very quickly which is important for
efficient method execution. However, this speed is obtained by restricting the
total amount of stack memory. If you try to run a recursive method to solve
a large problem you can easily exceed the amount of available stack memory
which will cause your program to crash. This lab demonstrates how
to transform a recursive method into an iterative method my manually
emulating the call stack. Students will use this technique to compute
Fibonacci numbers, but only a small amount of modification to the source
code is required to apply this technique to any recursive problem.
</p>

<h2>Fibonacci numbers</h2>

<p>
The sequence of numbers: 
</p>

<p>
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
</p>

<p>
is called the Fibonacci sequence.
The Fibonacci sequence can be defined recursively as:
</p>


<ul>
<li>F(0) = 0
</li>
<li>F(1) = 1
</li>
<li>F(n) = F(n - 1) + F(n - 2) for integer n &gt; 1
</li>
</ul>

<p>
In other words, the n<sup>th</sup> Fibonacci number is the sum of the previous
two Fibonacci numbers. 


</p><p>Consider the following recursive implementation for computing
the Fibonacci number F(n):
</p>

<pre>01  public class Fibonacci {
02    private static Map&lt;Integer, BigInteger&gt; cache = new HashMap&lt;Integer, BigInteger&gt;();
03
04    public static BigInteger fib(int n) {
05      BigInteger sum = null;
06      if (n == 0) {
07        sum = BigInteger.ZERO;
08      }
09      else if (n == 1) {
10        sum = BigInteger.ONE;
11      }
12      else if (Fibonacci.cache.containsKey(n)) {
13        sum = cache.get(n); 
14      }
15      else {
16        BigInteger fMinus1 = Fibonacci.fib(n - 1);
17        BigInteger fMinus2 = Fibonacci.fib(n - 2);
18        sum = fMinus1.add(fMinus2);
19        Fibonacci.cache.put(n, sum);
20      }
21      return sum;
22    }
23  }
</pre>

<p>
The implementation above uses a technique called <i>memoization</i>; it
stores the value of F(n) in the map named <code>cache</code> so that the
value of F(n) can be reused (instead of recursively recomputed) when
some larger Fibonacci number is computed. For example, invoking
<code>fib(5)</code> causes the values of F(5), F(4), F(3), and F(2) to
be stored in <code>cache</code>. If <code>fib(6)</code> is then invoked,
the values of F(5) and F(4) can be retrieved from the <code>cache</code>
to efficiently compute the value of F(6). It is possible to show that
the method above has complexity O(n) in contrast to the naive implementation
that does not use memoization which has complexity O(2<sup>n</sup>).
</p>

<p>
One problem with the above implementation, and with recursive implementations
in general, is that there is a limit to the amount of memory that can
be used to store the active method invocations, and this limit is much
smaller than the total amount of memory available. For example, on my
computer I can successfully invoke <code>fib(5411)</code>, but
invoking <code>fib(5412)</code> causes a <code>StackOverflowError</code>
exception to be thrown. To understand why a <code>StackOverflowError</code>
exception is thrown, consider the following illustration of what occurs
when <code>fib(3)</code> is invoked:
</p>

<p>
<img src="./Lab 7_ Emulating recursion using a stack_files/stackframe.png">
</p>

<ol>
<li>An invocation of <code>fib</code> begins execution to compute <b>F(3)</b>.
A block of memory called a <i>frame</i> that contains storage for the
method parameters, references to static variables, local variables, and the return
value is allocated from a part of memory called the <i>stack</i>. Because
the frame is allocated from the stack, the frame is often called a <i>stack frame</i>.
</li>
<li>To compute <b>F(3)</b>, an invocation of <code>fib</code> begins
execution to compute <b>F(2)</b>. Another block of memory is allocated for
the stack frame for <b>F(2)</b>.
</li>
<li>To compute <b>F(2)</b>, an invocation of <code>fib</code> begins
execution to compute <b>F(1)</b>. Another block of memory is allocated for
the stack frame for <b>F(1)</b>.
</li>
<li><b>F(1)</b> is a base case so the value of 1 can be returned
to the calling method <b>F(2)</b> and the memory associated with
the stack frame can be freed from use (or popped from the top of the stack).
</li>
<li>The method invocation that is computing <b>F(2)</b> (whose frame
is now on the top of the stack) receives the return value of <b>F(1)</b>,
and can resume execution.
</li>
<li>To continue computing <b>F(2)</b>, an invocation of <code>fib</code> begins
execution to compute <b>F(0)</b>. Another block of memory is allocated for
the stack frame for <b>F(0)</b>.
</li>
<li><b>F(0)</b> is a base case so the value of 0 can be returned
to the calling method <b>F(2)</b> and the memory associated with
the stack frame can be freed from use (or popped from the top of the stack).
</li>
<li>The method invocation that is computing <b>F(2)</b> (whose frame
is now on the top of the stack) receives the return value of <b>F(0)</b>,
and can resume execution. It computes the sum <b>F(1) + F(0)</b> and caches
the result.
</li>
<li>The method invocation that is computing <b>F(2)</b> is finished
execution so the value of 1 can be returned
to the calling method <b>F(3)</b> and the memory associated with
the stack frame can be freed from use (or popped from the top of the stack).
</li>

<li>The method invocation that is computing <b>F(3)</b> (whose frame
is now on the top of the stack) receives the return value of <b>F(2)</b>,
and can resume execution.
</li>
<li>To continue computing <b>F(3)</b>, an invocation of <code>fib</code> begins
execution to compute <b>F(1)</b>. Another block of memory is allocated for
the stack frame for <b>F(1)</b>.
</li>
<li><b>F(1)</b> is a base case so the value of 1 can be returned
to the calling method <b>F(3)</b> and the memory associated with
the stack frame can be freed from use (or popped from the top of the stack).
</li>
<li>The method invocation that is computing <b>F(3)</b> (whose frame
is now on the top of the stack) receives the return value of <b>F(1)</b>,
and can resume execution. It computes the sum <b>F(2) + F(1)</b> and caches
the result.
</li>
<li>The method invocation that is computing <b>F(3)</b> is finished
execution so the value of 2 can be returned
to the calling method and the memory associated with
the stack frame can be freed from use (or popped from the top of the stack).
</li>
</ol>

<p>
Notice that in the picture above, the stack of frames grows because
the bottom-most frame (which is trying to compute F(3)) must wait
for all of the frames above it to finish executing (to compute F(2)
and then F(1)) before it can finish executing. This can become problematic because
each stack frame requires enough memory to store:
</p>

<ul>
<li>the value of the parameter <code>n</code>
</li>
<li>a reference to <code>cache</code>
</li>
<li>the value of the return value <code>result</code>
</li>
<li>the value of the local variable <code>fMinus1</code> (used to store F(n - 1))
</li>
<li>the value of the local variable <code>fMinus2</code> (used to store F(n - 2))
</li>
<li>possibly some other book keeping values such as where the return value should
be copied to and the address of where the next stack frame is located
</li>
</ul>

<p>
When we try to invoke <code>fib(5412)</code> we end up with a stack of
5412 frames, each requiring memory as described above. This turns out to
exceed the available stack space on my JVM. Stack memory is special because
it can be allocated and deallocated very quickly; this is important for
efficient method execution. However, this speed is obtained by restricting the
amount of stack memory.
</p>

<p>
A larger pool of memory called the <i>heap</i> is available to your
program. Heap memory is used to store objects (i.e., heap memory
is allocated whenever the <code>new</code> operator is used). Allocating
and deallocating heap memory is slower than for stack memory, but the size of
the heap is much larger.
If we can convert our recursive implementation into an iterative implementation where
we replace stack frames with objects, then we might be able to compute
values such as <code>fib(5412)</code> and larger. To do so, we have to mimic
how the JVM implements its call stack by creating and managing our own stack
of frames.
</p>

<p>
Implement the class <code>FibonacciStackFrame</code>:
</p>

<ul>
<li>Add the classes <a href="https://www.eecs.yorku.ca/course_archive/2016-17/F/2030/labs/lab7/FibonacciStackFrame.java.txt">FibonacciStackFrame</a>
and <a href="https://www.eecs.yorku.ca/course_archive/2016-17/F/2030/labs/lab7/Fibonacci.java.txt">Fibonacci</a> to the
package <code>eecs2030.lab7</code>.
</li>
<li>The API for <code>FibonacciStackFrame</code> can be found
<a href="https://www.eecs.yorku.ca/course_archive/2016-17/F/2030/labs/lab7/doc/index.html">here</a>. Note that the API is unusual
in that it describes many implementation details (which are not normally
part of an API) to help you complete the implementation.
</li>
<li>
A <code>FibonacciStackFrame</code> has the following fields:

<ul>
<li>a static field named <code>cache</code> that corresponds to the <code>cache</code>
in the recursive implementation
</li>
<li>a field named <code>n</code> that stores which Fibonacci number
is being computed (the <b>n</b> in <b>F(n)</b>). The constructor should
set this field using the value passed into the constructor. 
</li>
<li>a field named <code>caller</code> that is a reference to the stack frame
that created this stack frame; this field is required so that this stack frame
knows where to return the value of <b>F(n)</b>. The constructor should
set this field using the value passed into the constructor.
</li>
<li>a field named <code>fMinus1</code> that stores the value of <b>F(n - 1)</b>
returned by another stack frame instance; this field corresponds to the
variable named <code>fMinus1</code> in the recursive implementation.
The constructor should set this field to zero.
</li>
<li>a field named <code>fMinus1Computed</code> that is set to <code>true</code> when
the stack frame has received a value for <code>fMinus1</code> from another
stack frame. The constructor should set this field to <code>false</code>.
</li>
<li>a field named <code>fMinus2</code> that stores the value of <b>F(n - 2)</b>
returned by another stack frame instance; this field corresponds to the
variable named <code>fMinus2</code> in the recursive implementation.
The constructor should set this field to zero.
</li>
<li>a field named <code>fMinus2Computed</code> that is set to <code>true</code> when
the stack frame has received a value for <code>fMinus2</code> from another
stack frame. The constructor should set this field to <code>false</code>.
</li>
<li>a field named <code>sum</code> that stores the value of <b>F(n - 1) + F(n - 2)</b>
returned by another stack frame instance; this field corresponds to the
variable named <code>sum</code> in the recursive implementation.
The constructor should set this field to zero.
</li>
</ul>
</li>
<li>
The method <code>receiveReturnValue</code> simulates lines 16 and 17 of the
recursive method. This method should be called exactly twice by two other
<code>FibonacciStackFrame</code> instances (once to set the value of
<code>fMinus1</code> and once to set the value of <code>fMinus2</code>).
</li>
<li>
The method <code>returnValueToCaller</code> simulates line 21 of
the recursive method. This method should invoke <code>receiveReturnValue</code>
on the creator of this stack frame (if the creator is not <code>null</code>)
and then pop the call stack.
</li>
<li>
The method <code>getReturnValue</code> allows the client that created the initial
<code>FibonacciStackFrame</code> instance to retrieve the final value
of <b>F(n)</b>
</li>
<li>
The method <code>execute</code> simulates lines 6 through 21 of the
recursive method. To simulate a recursive invocation, you should create
a new <code>FibonacciStackFrame</code> instance and push it onto the
call stack.
</li>
<li>
Test your stack using the JUnit test 
<a href="https://www.eecs.yorku.ca/course_archive/2016-17/F/2030/labs/lab7/FibonacciStackFrameTest.java.txt">FibonacciStackFrameTest</a>.
</li>
<li>
Use the method <code>fib2</code> in the <code>Fibonacci</code> class
to compute the value of <b>F(10000)</b> by running the <code>main</code>
method in the <code>Fibonacci</code> class.
</li>
</ul>

<h2>Submission instructions</h2>

<p>Please wait a couple of days before submitting your solution</p>

<p>
Submit your solution using the command:
</p>

<pre>submit 2030 lab7 FibonacciStackFrame.java
</pre>

<p>
or if you are working in a group:
</p>

<pre>submit 2030 lab7 FibonacciStackFrame.java group.txt
</pre>




</body></html>